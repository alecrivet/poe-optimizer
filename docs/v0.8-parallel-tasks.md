# v0.8 Parallel Task Breakdown

## Dependency Graph

```
                    ┌─────────────────┐
                    │  Tree Position  │
                    │    Parsing      │
                    │   (Stream B1)   │
                    └────────┬────────┘
                             │
                             ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│    Mastery      │  │     Radius      │  │   Timeless      │
│   Calculator    │  │   Calculator    │  │  Data Parser    │
│   (Stream A1)   │  │   (Stream B2)   │  │   (Stream C1)   │
└────────┬────────┘  └────────┬────────┘  └────────┬────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐
│  Batch Mastery  │  │  Thread of Hope │  │ Timeless Value  │
│   Evaluation    │  │   Optimizer     │  │   Calculator    │
│   (Stream A2)   │  │   (Stream B3)   │  │   (Stream C2)   │
└────────┬────────┘  └────────┴────────┘  └────────┬────────┘
         │                    │                    │
         ▼                    ▼                    ▼
┌─────────────────┐           │           ┌─────────────────┐
│    Mastery      │           │           │   Timeless      │
│    Synergy      │           │           │  Recommendations│
│   (Stream A3)   │           │           │   (Stream C3)   │
└─────────────────┘           │           └─────────────────┘
                              │
┌─────────────────┐           │           ┌─────────────────┐
│  Build Context  │           │           │    Cluster      │
│   Extraction    │◄──────────┴──────────►│   Optimizer     │
│   (Stream D)    │                       │   (Stream E)    │
└─────────────────┘                       └─────────────────┘
```

## Parallel Streams Overview

| Stream | Name | Tasks | Can Start | Dependencies |
|--------|------|-------|-----------|--------------|
| **A** | Mastery Calculator | 3 tasks | Immediately | None |
| **B** | Radius Infrastructure | 3 tasks | Immediately | B2 needs B1 |
| **C** | Timeless Jewels | 3 tasks | Immediately | C2 needs C1 |
| **D** | Build Context | 1 task | Immediately | None |
| **E** | Cluster Optimization | 3 tasks | Immediately | Internal only |

**Maximum parallelism: 5 agents working simultaneously**

---

## Stream A: Mastery Calculator (Critical Path)

### Task A1: Calculator-Based Mastery Evaluation

**File to create:** `src/pob/mastery_optimizer.py` (modify existing)

**Objective:** Replace heuristic scoring with actual PoB calculations

**Interface Contract:**
```python
def _evaluate_effect_with_calculator(
    self,
    base_xml: str,
    mastery_node_id: int,
    effect_id: int,
    calculator: RelativeCalculator,
    objective: str
) -> float:
    """
    Evaluate a single mastery effect by modifying build and calculating.

    Args:
        base_xml: Original build XML
        mastery_node_id: The mastery node ID
        effect_id: The effect to test
        calculator: RelativeCalculator instance
        objective: 'dps', 'life', 'ehp', or 'balanced'

    Returns:
        Score for this effect (percentage improvement)
    """
```

**Implementation Steps:**
1. Create modified XML with the mastery effect applied
2. Call `calculator.evaluate_modification(base_xml, modified_xml)`
3. Extract objective-appropriate score from result
4. Return score

**Test Cases:**
- Effect that should improve DPS scores positive for 'dps' objective
- Effect that should improve Life scores positive for 'life' objective
- Calculator result matches manual PoB verification

**Effort:** 1 day
**Dependencies:** None
**Output:** Working `_evaluate_effect_with_calculator()` method

---

### Task A2: Batch Mastery Evaluation

**File to modify:** `src/pob/mastery_optimizer.py`

**Objective:** Evaluate all mastery options efficiently using BatchCalculator

**Interface Contract:**
```python
def select_best_mastery_effects_batch(
    self,
    base_xml: str,
    allocated_nodes: Set[int],
    current_effects: Dict[int, int],
    objective: str,
    batch_calculator: BatchCalculator
) -> Dict[int, int]:
    """
    Evaluate all mastery options using batch evaluation.

    Args:
        base_xml: Original build XML
        allocated_nodes: Currently allocated passive nodes
        current_effects: Current mastery selections {node_id: effect_id}
        objective: Optimization objective
        batch_calculator: BatchCalculator instance

    Returns:
        Best effect for each mastery node {node_id: best_effect_id}
    """
```

**Implementation Steps:**
1. Identify all mastery nodes in allocated_nodes
2. For each mastery, generate modified XML for each available effect
3. Submit all modifications to batch_calculator.evaluate_batch()
4. Parse results and select best effect per mastery
5. Return optimal selections

**Test Cases:**
- Batch results match sequential evaluation
- Performance: 15 masteries × 5 options evaluates in <30 seconds
- Handles edge cases (no masteries, single mastery)

**Effort:** 1.5 days
**Dependencies:** Task A1 complete
**Output:** Working `select_best_mastery_effects_batch()` method

---

### Task A3: Mastery Synergy Detection

**File to create:** `src/pob/mastery_synergy.py`

**Objective:** Detect masteries that work better together

**Interface Contract:**
```python
@dataclass
class MasterySynergy:
    effect_ids: Tuple[int, int]
    synergy_type: str  # 'additive', 'multiplicative', 'enabling'
    combined_value: float
    individual_sum: float
    synergy_bonus: float  # combined - individual_sum

class MasterySynergyDetector:
    def detect_synergies(
        self,
        build_xml: str,
        mastery_effects: Dict[int, int],
        calculator: RelativeCalculator,
        threshold: float = 0.5  # Minimum synergy bonus %
    ) -> List[MasterySynergy]:
        """
        Detect synergies between allocated mastery effects.

        Returns list of synergies where combined value exceeds
        sum of individual values by more than threshold.
        """
```

**Implementation Steps:**
1. For each pair of mastery effects:
   - Evaluate effect1 alone
   - Evaluate effect2 alone
   - Evaluate both together
   - If combined > sum + threshold, record synergy
2. Classify synergy type based on ratio
3. Return sorted by synergy_bonus

**Test Cases:**
- Known synergies detected (crit chance + crit multi)
- Non-synergistic effects don't trigger false positives
- Performance acceptable for 15+ masteries

**Effort:** 1.5 days
**Dependencies:** Task A1 complete
**Output:** Working `MasterySynergyDetector` class

---

## Stream B: Radius Infrastructure

### Task B1: Tree Position Parsing

**File to create:** `src/pob/tree_positions.py`

**Objective:** Parse node X,Y coordinates from PoB tree data

**Interface Contract:**
```python
@dataclass
class NodePosition:
    node_id: int
    x: float
    y: float
    group: int  # Node group ID
    orbit: int  # Orbit within group
    orbit_index: int  # Position in orbit

class TreePositionLoader:
    def __init__(self, tree_version: str = "3_27"):
        """Initialize with PoE tree version."""

    def load_positions(self) -> Dict[int, NodePosition]:
        """
        Load all node positions from tree.lua.

        Returns:
            Dict mapping node_id to NodePosition
        """

    def get_position(self, node_id: int) -> Optional[NodePosition]:
        """Get position for a single node."""
```

**Data Source:** `PathOfBuilding/src/TreeData/{version}/tree.lua`

**Parsing Notes:**
- Nodes defined in Lua tables with `["x"]`, `["y"]` fields
- Some nodes use group/orbit positioning instead of direct x,y
- Need to handle both formats

**Test Cases:**
- All jewel socket positions loaded correctly
- Position count matches expected (~1300 nodes)
- Known node positions match PoB display

**Effort:** 1.5 days
**Dependencies:** None
**Output:** Working `TreePositionLoader` class with cached positions

---

### Task B2: Radius Calculator

**File to create:** `src/pob/jewel/radius_calculator.py`

**Objective:** Calculate which nodes fall within jewel radii

**Interface Contract:**
```python
class RadiusCalculator:
    # Radius thresholds (PoB distance units)
    SMALL_RADIUS = 800
    MEDIUM_RADIUS = 1200
    LARGE_RADIUS = 1800

    def __init__(self, positions: Dict[int, NodePosition]):
        """Initialize with node positions."""

    def distance(self, node1_id: int, node2_id: int) -> float:
        """Calculate distance between two nodes."""

    def get_nodes_in_radius(
        self,
        center_node_id: int,
        radius: int
    ) -> Set[int]:
        """Get all nodes within radius of center node."""

    def get_nodes_in_ring(
        self,
        center_node_id: int,
        inner_radius: int,
        outer_radius: int
    ) -> Set[int]:
        """Get nodes in ring (for Thread of Hope)."""

    def precompute_socket_radii(
        self,
        socket_ids: Set[int]
    ) -> Dict[int, Dict[str, Set[int]]]:
        """
        Precompute radius nodes for all sockets.

        Returns:
            {socket_id: {'small': Set, 'medium': Set, 'large': Set}}
        """
```

**Implementation Notes:**
- Use Euclidean distance between x,y coordinates
- Cache results (socket radii are static per tree version)
- Consider spatial indexing for performance (optional)

**Test Cases:**
- Known jewel socket has correct nodes in radius
- Ring calculation correct for Thread of Hope
- Precomputation completes in <1 second

**Effort:** 1.5 days
**Dependencies:** Task B1 complete
**Output:** Working `RadiusCalculator` class

---

### Task B3: Thread of Hope Optimizer

**File to create:** `src/pob/jewel/thread_of_hope.py`

**Objective:** Optimize Thread of Hope placement

**Interface Contract:**
```python
@dataclass
class ThreadOfHopePlacement:
    socket_node_id: int
    ring_nodes: Set[int]  # Nodes allocatable via ring
    ring_notables: Set[int]  # Notable nodes in ring
    pathing_cost: int  # Points to reach socket
    potential_savings: int  # Points saved vs normal pathing
    value_score: float  # Estimated value of ring notables

class ThreadOfHopeOptimizer:
    def __init__(
        self,
        radius_calc: RadiusCalculator,
        tree_graph: PassiveTree
    ):
        """Initialize with radius calculator and tree graph."""

    def analyze_socket(
        self,
        socket_id: int,
        allocated_nodes: Set[int],
        ring_size: str  # 'small', 'medium', 'large', 'very_large'
    ) -> ThreadOfHopePlacement:
        """Analyze a single socket for Thread of Hope."""

    def find_optimal_placement(
        self,
        build_xml: str,
        ring_size: str,
        objective: str,
        calculator: Optional[RelativeCalculator] = None
    ) -> List[ThreadOfHopePlacement]:
        """
        Find best sockets for Thread of Hope.

        Returns:
            List of placements sorted by value_score
        """

    def generate_candidates(
        self,
        current_xml: str,
        current_socket: Optional[int],
        objective: str
    ) -> Dict[str, str]:
        """
        Generate optimizer candidates for Thread of Hope moves.

        Returns:
            Dict of {description: modified_xml}
        """
```

**Thread of Hope Ring Sizes:**
- Small: 12-15 units inner, 24-27 outer
- Medium: 16-19 inner, 30-33 outer
- Large: 20-23 inner, 36-39 outer
- Very Large: 24-27 inner, 42-45 outer

**Test Cases:**
- Correct ring nodes identified for each size
- Pathing cost calculation accurate
- Candidates integrate with optimizer

**Effort:** 2 days
**Dependencies:** Task B2 complete
**Output:** Working `ThreadOfHopeOptimizer` class

---

## Stream C: Timeless Jewels

### Task C1: Timeless Data Parser

**File to create:** `src/pob/jewel/timeless_data.py`

**Objective:** Parse PoB's TimelessJewelData files

**Data Source:** `PathOfBuilding/src/Data/TimelessJewelData/`
- `GloriousVanity.lua` (~10MB)
- `LethalPride.lua` (~10MB)
- `ElegantHubris.lua` (~10MB)
- `MilitantFaith.lua` (~10MB)
- `BrutalRestraint.lua` (~10MB)

**Interface Contract:**
```python
@dataclass
class TimelessNodeMod:
    stat_id: int
    stat_value: float
    stat_text: str  # Human readable

@dataclass
class TimelessTransformation:
    original_node_id: int
    mods: List[TimelessNodeMod]
    replaces_original: bool  # True for Elegant Hubris

class TimelessJewelDataLoader:
    def __init__(self, data_dir: str = None):
        """Initialize with path to TimelessJewelData directory."""

    def load_jewel_type(self, jewel_type: str) -> bool:
        """
        Lazy load data for a jewel type.

        Args:
            jewel_type: 'GloriousVanity', 'LethalPride', etc.

        Returns:
            True if loaded successfully
        """

    def get_transformations(
        self,
        jewel_type: str,
        seed: int,
        node_ids: Set[int]
    ) -> Dict[int, TimelessTransformation]:
        """
        Get transformations for nodes with given seed.

        Args:
            jewel_type: Type of timeless jewel
            seed: The jewel's seed number
            node_ids: Nodes to look up (in radius)

        Returns:
            Dict of {node_id: TimelessTransformation}
        """

    def is_loaded(self, jewel_type: str) -> bool:
        """Check if jewel type data is loaded."""
```

**Parsing Strategy:**
- Files are Lua tables: `return { [seed] = { [node_id] = {...}, ... }, ... }`
- Use regex or lua parser library
- Lazy load (don't load all 50MB at startup)
- Cache parsed data in memory with LRU eviction

**Test Cases:**
- Parse sample seed from each jewel type
- Transformation lookup returns correct mods
- Memory usage acceptable (<100MB per loaded type)
- Load time <5 seconds per jewel type

**Effort:** 2 days
**Dependencies:** None
**Output:** Working `TimelessJewelDataLoader` class

---

### Task C2: Timeless Value Calculator

**File to create:** `src/pob/jewel/timeless_value.py`

**Objective:** Calculate value of timeless jewel at different sockets

**Interface Contract:**
```python
@dataclass
class TimelessSocketAnalysis:
    socket_node_id: int
    affected_nodes: Set[int]
    transformations: Dict[int, TimelessTransformation]
    total_value: float  # Aggregate value for objective
    best_nodes: List[Tuple[int, float]]  # Top transformed nodes
    pathing_cost: int

class TimelessValueCalculator:
    def __init__(
        self,
        data_loader: TimelessJewelDataLoader,
        radius_calc: RadiusCalculator,
        tree_graph: PassiveTree
    ):
        """Initialize with dependencies."""

    def analyze_socket(
        self,
        jewel: TimelessJewel,
        socket_id: int,
        allocated_nodes: Set[int],
        objective: str,
        calculator: Optional[RelativeCalculator] = None
    ) -> TimelessSocketAnalysis:
        """
        Analyze timeless jewel value at a socket.

        If calculator provided, uses actual build calculations.
        Otherwise uses heuristic stat scoring.
        """

    def compare_sockets(
        self,
        jewel: TimelessJewel,
        socket_ids: Set[int],
        allocated_nodes: Set[int],
        objective: str
    ) -> List[TimelessSocketAnalysis]:
        """
        Compare multiple sockets for a timeless jewel.

        Returns:
            Analyses sorted by total_value descending
        """

    def score_transformation(
        self,
        transform: TimelessTransformation,
        objective: str
    ) -> float:
        """Score a single transformation for objective."""
```

**Scoring Logic:**
- DPS: Damage mods, crit, attack/cast speed
- Life: Max life, life regen, strength
- EHP: Resistances, armor, evasion, ES
- Use stat_text parsing similar to mastery heuristics

**Test Cases:**
- Socket with more DPS nodes scores higher for 'dps'
- Calculator-based matches heuristic direction
- Performance: <1 second per socket analysis

**Effort:** 2 days
**Dependencies:** Task C1, Task B2 complete
**Output:** Working `TimelessValueCalculator` class

---

### Task C3: Timeless Recommendations

**File to modify:** `src/pob/jewel/timeless.py`

**Objective:** Add recommendation methods to TimelessJewel

**Interface Contract:**
```python
# Add to existing TimelessJewel class

class TimelessJewel(BaseJewel):
    # ... existing fields ...

    def get_socket_recommendations(
        self,
        build_xml: str,
        objective: str,
        value_calc: TimelessValueCalculator,
        top_n: int = 5
    ) -> List[TimelessSocketAnalysis]:
        """
        Get recommended sockets for this jewel.

        Returns:
            Top N sockets by value, sorted descending
        """

    def get_current_value(
        self,
        build_xml: str,
        objective: str,
        value_calc: TimelessValueCalculator
    ) -> TimelessSocketAnalysis:
        """Get analysis of current socket placement."""

    def format_recommendations(
        self,
        recommendations: List[TimelessSocketAnalysis]
    ) -> str:
        """Format recommendations for CLI output."""
```

**CLI Integration:**
```bash
# Add to jewels command
poe-optimizer jewels build.xml --analyze-timeless
```

**Test Cases:**
- Recommendations generated for test build
- Current socket included in output
- Format readable in CLI

**Effort:** 1 day
**Dependencies:** Task C2 complete
**Output:** Updated `TimelessJewel` with recommendations

---

## Stream D: Build Context

### Task D1: Build Context Extraction

**File to create:** `src/pob/build_context.py`

**Objective:** Extract build characteristics for context-aware scoring

**Interface Contract:**
```python
@dataclass
class BuildContext:
    # Damage
    primary_damage_type: str  # 'physical', 'fire', 'cold', 'lightning', 'chaos'
    secondary_damage_types: Set[str]
    damage_style: str  # 'hit', 'dot', 'minion'
    attack_or_spell: str  # 'attack', 'spell', 'both'

    # Defense
    defense_style: str  # 'life', 'es', 'hybrid'
    primary_mitigation: str  # 'armor', 'evasion', 'block', 'dodge'

    # Class/Ascendancy
    character_class: str  # 'Marauder', 'Witch', etc.
    ascendancy: str  # 'Slayer', 'Necromancer', etc.

    # Mechanics
    key_mechanics: Set[str]  # 'totems', 'brands', 'traps', 'mines', 'minions'
    key_keystones: Set[str]  # 'Resolute Technique', 'CI', etc.

    @classmethod
    def from_build_xml(cls, xml: str) -> "BuildContext":
        """Extract context from PoB build XML."""

    def get_relevant_keywords(self, objective: str) -> Dict[str, float]:
        """
        Get context-aware keyword weights.

        Returns:
            Dict of {keyword: weight} for scoring
        """

class BuildContextExtractor:
    def extract(self, build_xml: str) -> BuildContext:
        """Full extraction pipeline."""

    def _parse_ascendancy(self, xml: str) -> Tuple[str, str]:
        """Extract class and ascendancy from Spec."""

    def _analyze_skills(self, xml: str) -> Dict[str, Any]:
        """Analyze active skills for damage types."""

    def _analyze_keystones(self, xml: str) -> Set[str]:
        """Find allocated keystones."""

    def _analyze_defenses(self, xml: str) -> Dict[str, str]:
        """Determine defense style from tree and gear."""
```

**Extraction Sources:**
- `<Spec>` element: ascendancy, allocated nodes
- `<Skills>` element: active gems, support gems
- `<Items>` element: gear for defense style hints
- Keystones: CI, EB, MoM, Acrobatics, etc.

**Test Cases:**
- Correctly identifies attack vs spell builds
- Correctly identifies damage types
- Correctly identifies defense style
- Works on various build archetypes

**Effort:** 2 days
**Dependencies:** None
**Output:** Working `BuildContext` and `BuildContextExtractor` classes

---

## Stream E: Cluster Optimization

### Task E1: Cluster Subgraph Modeling

**File to create:** `src/pob/jewel/cluster_subgraph.py`

**Objective:** Model cluster jewel subgraphs for optimization

**Interface Contract:**
```python
@dataclass
class ClusterNode:
    node_id: int
    name: str
    is_notable: bool
    is_socket: bool  # For nested clusters
    stats: List[str]
    connections: Set[int]  # Connected node IDs within subgraph

@dataclass
class ClusterSubgraph:
    jewel: ClusterJewel
    socket_node: int  # Entry point from main tree
    nodes: Dict[int, ClusterNode]
    notables: List[int]  # Notable node IDs
    small_passives: List[int]
    nested_sockets: List[int]

    def get_paths_to_notable(self, notable_id: int) -> List[List[int]]:
        """Get all paths from socket to notable."""

    def get_minimum_allocation(self, notables: Set[int]) -> Set[int]:
        """
        Get minimum nodes needed to allocate given notables.

        Uses shortest path from socket through each notable.
        """

    def get_allocation_cost(self, notables: Set[int]) -> int:
        """Get point cost for allocating given notables."""

    def is_valid_allocation(self, nodes: Set[int]) -> bool:
        """Check if allocation is connected to socket."""

class ClusterSubgraphBuilder:
    def build_from_jewel(
        self,
        cluster: ClusterJewel,
        allocated_nodes: Set[int]
    ) -> ClusterSubgraph:
        """Build subgraph model from cluster jewel."""

    def build_from_xml(
        self,
        build_xml: str,
        cluster: ClusterJewel
    ) -> ClusterSubgraph:
        """Build subgraph with node details from PoB."""
```

**Node ID Decoding (from existing code):**
```python
# Bits 0-3:   Node index (0-11)
# Bits 4-5:   Group size (0=Small, 1=Medium, 2=Large)
# Bits 6-8:   Large socket index (0-5)
# Bits 9-10:  Medium socket index (0-2)
# Bit 16:     Signal bit (always 1)
```

**Test Cases:**
- Correct node count per cluster size
- Paths to notables calculated correctly
- Minimum allocation finds shortest path
- Invalid allocations rejected

**Effort:** 2 days
**Dependencies:** None
**Output:** Working `ClusterSubgraph` and builder classes

---

### Task E2: Protected Node Relaxation

**File to modify:** `src/pob/jewel/registry.py`

**Objective:** Allow optional optimization within cluster subgraphs

**Interface Contract:**
```python
class JewelRegistry:
    def get_protected_nodes(
        self,
        allocated_nodes: Optional[Set[int]] = None,
        protect_empty_sockets: bool = True,
        allow_cluster_optimization: bool = False  # NEW
    ) -> Set[int]:
        """
        Get nodes that should not be modified.

        Args:
            allocated_nodes: Currently allocated nodes
            protect_empty_sockets: Protect unoccupied sockets
            allow_cluster_optimization: If True, only protect
                cluster socket entry points, not all cluster nodes

        Returns:
            Set of protected node IDs
        """

    def get_cluster_subgraphs(
        self,
        allocated_nodes: Set[int]
    ) -> List[ClusterSubgraph]:
        """Get subgraph models for all cluster jewels."""
```

**Behavior Change:**
```python
# Current (allow_cluster_optimization=False):
protected = socket_nodes + ALL cluster_nodes

# New (allow_cluster_optimization=True):
protected = socket_nodes + cluster_socket_entry_points_only
# Optimizer can reallocate within cluster subgraphs
```

**Safety Checks:**
- Cluster socket must remain allocated
- Subgraph connectivity maintained
- At least one path from socket to any allocated notable

**Test Cases:**
- Default behavior unchanged
- New flag allows cluster node removal
- Connectivity validation prevents orphaned nodes

**Effort:** 1 day
**Dependencies:** Task E1 complete
**Output:** Updated `JewelRegistry` with cluster optimization flag

---

### Task E3: Cluster Notable Selection

**File to create:** `src/pob/jewel/cluster_optimizer.py`

**Objective:** Optimize notable selection within clusters

**Interface Contract:**
```python
@dataclass
class ClusterAllocation:
    subgraph: ClusterSubgraph
    allocated_notables: Set[int]
    allocated_small: Set[int]
    total_points: int
    value_score: float

class ClusterNotableOptimizer:
    def __init__(
        self,
        calculator: Optional[RelativeCalculator] = None
    ):
        """Initialize with optional calculator."""

    def evaluate_notable(
        self,
        subgraph: ClusterSubgraph,
        notable_id: int,
        current_allocation: Set[int],
        base_xml: str,
        objective: str
    ) -> float:
        """Evaluate value of adding a notable."""

    def optimize_allocation(
        self,
        subgraph: ClusterSubgraph,
        base_xml: str,
        objective: str,
        max_points: Optional[int] = None
    ) -> ClusterAllocation:
        """
        Find optimal notable allocation for cluster.

        Args:
            subgraph: The cluster subgraph to optimize
            base_xml: Current build XML
            objective: Optimization objective
            max_points: Optional point limit within cluster

        Returns:
            Optimal allocation with value score
        """

    def generate_candidates(
        self,
        subgraph: ClusterSubgraph,
        current_xml: str,
        objective: str
    ) -> Dict[str, str]:
        """
        Generate optimizer candidates for cluster changes.

        Returns:
            Dict of {description: modified_xml}
        """
```

**Optimization Strategy:**
1. Start with socket node only
2. Evaluate each notable: value vs point cost
3. Greedy add highest efficiency notables
4. Or exhaustive search if few notables (3-4)

**Test Cases:**
- Correctly identifies valuable notables
- Point cost calculation accurate
- Generated candidates valid XML
- Integration with main optimizer works

**Effort:** 2 days
**Dependencies:** Tasks E1, E2 complete
**Output:** Working `ClusterNotableOptimizer` class

---

## Integration Tasks (After Parallel Streams)

### Task I1: Optimizer Integration - Mastery

**Files to modify:**
- `src/optimizer/tree_optimizer.py`
- `src/optimizer/genetic_optimizer.py`

**Changes:**
1. Update `_optimize_masteries_for_tree()` to use calculator
2. Add batch_calculator parameter to optimization methods
3. Update mastery candidate generation to use new evaluation

**Effort:** 1 day
**Dependencies:** Stream A complete

---

### Task I2: Optimizer Integration - Radius Jewels

**Files to modify:**
- `src/optimizer/tree_optimizer.py`
- `src/optimizer/genetic_optimizer.py`

**Changes:**
1. Add Thread of Hope candidate generation
2. Integrate radius-aware jewel mutations
3. Update jewel swap logic with radius considerations

**Effort:** 1 day
**Dependencies:** Stream B complete

---

### Task I3: Optimizer Integration - Clusters

**Files to modify:**
- `src/optimizer/tree_optimizer.py`
- `src/optimizer/genetic_optimizer.py`

**Changes:**
1. Add cluster reallocation candidates (opt-in)
2. Update protected nodes logic
3. Add cluster-specific mutations

**Effort:** 1 day
**Dependencies:** Stream E complete

---

### Task I4: CLI Enhancements

**File to modify:** `src/cli/commands/jewels.py`

**Changes:**
1. Add `--analyze-timeless` flag
2. Add `--analyze-threads` flag (Thread of Hope)
3. Add `--analyze-clusters` flag
4. Improved output formatting

**Effort:** 0.5 days
**Dependencies:** Streams B, C, E complete

---

## Parallel Execution Plan

### Phase 1: Independent Streams (5 agents simultaneously)

```
Agent 1: Stream A (Mastery Calculator)
  Day 1: Task A1 (Calculator-based evaluation)
  Day 2-3: Task A2 (Batch evaluation)
  Day 4: Task A3 (Synergy detection)

Agent 2: Stream B (Radius Infrastructure)
  Day 1-2: Task B1 (Tree positions)
  Day 2-3: Task B2 (Radius calculator)
  Day 4-5: Task B3 (Thread of Hope)

Agent 3: Stream C (Timeless Jewels)
  Day 1-2: Task C1 (Data parser)
  Day 3-4: Task C2 (Value calculator)
  Day 5: Task C3 (Recommendations)

Agent 4: Stream D (Build Context)
  Day 1-2: Task D1 (Context extraction)
  Day 3: Integration with mastery scoring

Agent 5: Stream E (Cluster Optimization)
  Day 1-2: Task E1 (Subgraph modeling)
  Day 3: Task E2 (Protected relaxation)
  Day 4-5: Task E3 (Notable selection)
```

### Phase 2: Integration (2 agents)

```
Agent 6: Integration Tasks
  Day 1: Task I1 (Mastery integration)
  Day 2: Task I2 (Radius integration)
  Day 3: Task I3 (Cluster integration)

Agent 7: Testing & CLI
  Day 1-2: Integration tests
  Day 3: Task I4 (CLI enhancements)
  Day 4: Documentation
```

### Timeline Summary

- **Phase 1:** 5 days (parallel)
- **Phase 2:** 4 days (2 agents)
- **Total elapsed:** ~7-8 days with parallelization
- **Total effort:** ~20 agent-days

---

## File Ownership Matrix

| File | Owner Stream | Touches |
|------|--------------|---------|
| `src/pob/mastery_optimizer.py` | A | A1, A2 |
| `src/pob/mastery_synergy.py` | A | A3 |
| `src/pob/tree_positions.py` | B | B1 |
| `src/pob/jewel/radius_calculator.py` | B | B2 |
| `src/pob/jewel/thread_of_hope.py` | B | B3 |
| `src/pob/jewel/timeless_data.py` | C | C1 |
| `src/pob/jewel/timeless_value.py` | C | C2 |
| `src/pob/jewel/timeless.py` | C | C3 |
| `src/pob/build_context.py` | D | D1 |
| `src/pob/jewel/cluster_subgraph.py` | E | E1 |
| `src/pob/jewel/cluster_optimizer.py` | E | E3 |
| `src/pob/jewel/registry.py` | E | E2 |
| `src/optimizer/tree_optimizer.py` | Integration | I1, I2, I3 |
| `src/optimizer/genetic_optimizer.py` | Integration | I1, I2, I3 |
| `src/cli/commands/jewels.py` | Integration | I4 |

---

## Communication Interfaces

### Between Streams

**B → C:** RadiusCalculator needed by TimelessValueCalculator
```python
# Stream C imports from Stream B
from src.pob.jewel.radius_calculator import RadiusCalculator
```

**B → E:** RadiusCalculator useful for cluster analysis
```python
# Optional import
from src.pob.jewel.radius_calculator import RadiusCalculator
```

**A → D:** BuildContext can enhance mastery scoring
```python
# Stream A can use Stream D's output
from src.pob.build_context import BuildContext
```

### Shared Dependencies

All streams depend on:
- `src/pob/jewel/base.py` (read-only)
- `src/pob/modifier.py` (read-only for most)
- `src/pob/relative_calculator.py` (read-only)
- `src/pob/batch_calculator.py` (read-only)

---

*Document created: January 2025*
*For v0.8.0 parallel development*
