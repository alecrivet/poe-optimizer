"""
Cluster Jewel Support

Cluster jewels dynamically add nodes to the passive tree. They come in 3 sizes:

1. Large Cluster Jewel (6-12 nodes)
   - 2-3 notable passives
   - 2 medium jewel sockets
   - Socketed in outer jewel sockets

2. Medium Cluster Jewel (4-6 nodes)
   - 1-2 notable passives
   - 1 small jewel socket
   - Socketed in large cluster sockets

3. Small Cluster Jewel (2-3 nodes)
   - 1 notable passive
   - No jewel sockets
   - Socketed in medium cluster sockets

IMPORTANT: Cluster jewel nodes use IDs >= 65536 (bit 16 set) to avoid
collision with regular tree node IDs.

Node ID Encoding (from PoB PassiveSpec.lua):
- Bits 0-3:  Node index (0-11)
- Bits 4-5:  Group size (0=Small, 1=Medium, 2=Large)
- Bits 6-8:  Large socket index (0-5)
- Bits 9-10: Medium socket index (0-2)
- Bit 16:    Signal bit (always 1)
"""

import re
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Optional, Set, Dict, TYPE_CHECKING

from .base import BaseJewel, JewelCategory

if TYPE_CHECKING:
    from ..tree_parser import PassiveTreeGraph


class ClusterJewelSize(Enum):
    """Cluster jewel sizes."""

    SMALL = "Small"
    MEDIUM = "Medium"
    LARGE = "Large"

    @property
    def min_nodes(self) -> int:
        return {ClusterJewelSize.SMALL: 2, ClusterJewelSize.MEDIUM: 4, ClusterJewelSize.LARGE: 6}[
            self
        ]

    @property
    def max_nodes(self) -> int:
        return {ClusterJewelSize.SMALL: 3, ClusterJewelSize.MEDIUM: 6, ClusterJewelSize.LARGE: 12}[
            self
        ]

    @property
    def size_index(self) -> int:
        """Index used in node ID encoding."""
        return {ClusterJewelSize.SMALL: 0, ClusterJewelSize.MEDIUM: 1, ClusterJewelSize.LARGE: 2}[
            self
        ]


# Minimum node ID for cluster jewel nodes
CLUSTER_NODE_MIN_ID = 65536  # 0x10000


@dataclass
class ClusterJewel(BaseJewel):
    """
    Represents a cluster jewel in a PoB build.

    Cluster jewels are unique because they dynamically generate
    passive tree nodes. These nodes must be treated as protected
    to avoid corrupting the subgraph structure.

    Attributes:
        size: Small, Medium, or Large
        enchant_type: The enchant that determines small passive stats
        enchant_stat: The actual stat text (e.g., "4% increased maximum Life")
        notables: List of notable passive names on this jewel
        generated_nodes: List of node IDs generated by this jewel (>= 65536)
    """

    size: ClusterJewelSize = ClusterJewelSize.LARGE
    enchant_type: str = ""  # e.g., "affliction_maximum_life"
    enchant_stat: str = ""  # e.g., "4% increased maximum Life"
    notables: List[str] = field(default_factory=list)
    generated_nodes: List[int] = field(default_factory=list)
    nested_sockets: List[int] = field(default_factory=list)  # Socket node IDs for nested jewels

    def __post_init__(self):
        self.category = JewelCategory.CLUSTER

    def get_affected_nodes(self, tree: "PassiveTreeGraph") -> Set[int]:
        """
        Return the dynamically generated nodes for this cluster jewel.

        These are the nodes created by PoB's BuildClusterJewelGraphs().
        They should be treated as immutable by the optimizer.
        """
        return set(self.generated_nodes)

    @property
    def display_name(self) -> str:
        """Human-readable name for the jewel."""
        notable_str = ", ".join(self.notables[:2]) if self.notables else "no notables"
        return f"{self.size.value} Cluster Jewel ({notable_str})"

    @property
    def is_protected(self) -> bool:
        """
        Cluster jewel nodes should always be protected from modification.

        The optimizer should not try to add or remove cluster nodes,
        as this could corrupt the subgraph structure.
        """
        return True

    def get_node_count(self) -> int:
        """Get the number of passive nodes in this cluster."""
        return len(self.generated_nodes)


def parse_cluster_jewels(build_xml: str) -> List[ClusterJewel]:
    """
    Extract cluster jewels from PoB build XML.

    Note: This only parses the item data. The generated node IDs
    must be obtained from PoB after the build is loaded.

    Args:
        build_xml: Full PoB build XML string

    Returns:
        List of ClusterJewel objects found in the build
    """
    jewels = []

    try:
        root = ET.fromstring(build_xml)

        # Find all items
        for items_elem in root.findall(".//Items"):
            for item_elem in items_elem.findall("Item"):
                item_id = item_elem.get("id")
                item_text = item_elem.text or ""

                # Check if it's a cluster jewel
                if "Cluster Jewel" in item_text:
                    jewel = _parse_cluster_jewel_item(item_text, item_id)
                    if jewel:
                        jewels.append(jewel)

        # Find socket assignments
        _assign_cluster_sockets(root, jewels)

    except Exception as e:
        import logging

        logging.warning(f"Error parsing cluster jewels: {e}")

    return jewels


def _parse_cluster_jewel_item(item_text: str, item_id: str) -> Optional[ClusterJewel]:
    """Parse a single cluster jewel item."""
    lines = item_text.strip().split("\n")

    # Determine size
    size = None
    if "Small Cluster Jewel" in item_text:
        size = ClusterJewelSize.SMALL
    elif "Medium Cluster Jewel" in item_text:
        size = ClusterJewelSize.MEDIUM
    elif "Large Cluster Jewel" in item_text:
        size = ClusterJewelSize.LARGE
    else:
        return None

    # Parse enchant (the "Added Small Passive Skills grant:" line)
    enchant_stat = ""
    enchant_type = ""
    for line in lines:
        if "Added Small Passive Skills grant:" in line:
            enchant_stat = line.replace("Added Small Passive Skills grant:", "").strip()
            enchant_type = _infer_enchant_type(enchant_stat)
            break

    # Parse notables (lines that look like notable names)
    notables = []
    # Notable names are typically capitalized multi-word names
    notable_pattern = re.compile(r"^[A-Z][a-z]+(?:\s+[A-Z][a-z]+)+$")
    # Also check for {crafted} or {fractured} prefixes
    for line in lines:
        clean_line = re.sub(r"\{[^}]+\}", "", line).strip()
        # Skip common non-notable lines
        if any(
            skip in clean_line
            for skip in [
                "Cluster Jewel",
                "Enchant",
                "Added Small",
                "Passive Skills",
                "Rarity:",
                "Item Level:",
                "Requires",
            ]
        ):
            continue
        # Check if it looks like a notable name (2+ words, capitalized)
        if notable_pattern.match(clean_line) and len(clean_line) > 5:
            notables.append(clean_line)

    return ClusterJewel(
        category=JewelCategory.CLUSTER,
        item_id=int(item_id) if item_id else 0,
        raw_text=item_text,
        size=size,
        enchant_type=enchant_type,
        enchant_stat=enchant_stat,
        notables=notables,
    )


def _infer_enchant_type(enchant_stat: str) -> str:
    """Infer the enchant type from the stat text."""
    # Map common stat texts to PoB enchant types
    stat_to_type = {
        "maximum Life": "affliction_maximum_life",
        "maximum Energy Shield": "affliction_maximum_energy_shield",
        "maximum Mana": "affliction_maximum_mana",
        "Armour": "affliction_armour",
        "Evasion": "affliction_evasion",
        "Fire Resistance": "affliction_fire_resistance",
        "Cold Resistance": "affliction_cold_resistance",
        "Lightning Resistance": "affliction_lightning_resistance",
        "Chaos Resistance": "affliction_chaos_resistance",
        "Block Attack Damage": "affliction_chance_to_block_attack_damage",
        "Block Spell Damage": "affliction_chance_to_block_spell_damage",
        "Strength": "affliction_strength",
        "Dexterity": "affliction_dexterity",
        "Intelligence": "affliction_intelligence",
    }

    for stat_key, type_name in stat_to_type.items():
        if stat_key in enchant_stat:
            return type_name

    return "unknown"


def _assign_cluster_sockets(root: ET.Element, jewels: List[ClusterJewel]) -> None:
    """Assign socket node IDs to cluster jewels."""
    # Look for sockets in Tree -> Spec -> Sockets
    for sockets_elem in root.findall(".//Sockets"):
        for socket in sockets_elem.findall("Socket"):
            item_id_str = socket.get("itemId")
            node_id_str = socket.get("nodeId")

            if item_id_str and item_id_str != "0" and node_id_str:
                try:
                    item_id = int(item_id_str)
                    node_id = int(node_id_str)

                    for jewel in jewels:
                        if jewel.item_id == item_id:
                            jewel.socket_node_id = node_id
                except ValueError:
                    continue

    # Also check ItemSet for alternate structure
    for item_set in root.findall(".//ItemSet"):
        for socket in item_set.findall(".//Socket"):
            item_id_str = socket.get("itemId")
            node_id_str = socket.get("nodeId")

            if item_id_str and item_id_str != "0" and node_id_str:
                try:
                    item_id = int(item_id_str)
                    node_id = int(node_id_str)

                    for jewel in jewels:
                        if jewel.item_id == item_id:
                            jewel.socket_node_id = node_id
                except ValueError:
                    continue


def is_cluster_node_id(node_id: int) -> bool:
    """
    Check if a node ID belongs to a cluster jewel subgraph.

    Cluster nodes have IDs >= 65536 (bit 16 is set).
    """
    return node_id >= CLUSTER_NODE_MIN_ID


def decode_cluster_node_id(node_id: int) -> Dict[str, int]:
    """
    Decode a cluster node ID into its components.

    Based on PoB's PassiveSpec.lua encoding:
    - Bits 0-3:  Node index (0-11)
    - Bits 4-5:  Group size (0=Small, 1=Medium, 2=Large)
    - Bits 6-8:  Large socket index (0-5)
    - Bits 9-10: Medium socket index (0-2)

    Args:
        node_id: The cluster node ID (must be >= 65536)

    Returns:
        Dictionary with decoded components
    """
    if node_id < CLUSTER_NODE_MIN_ID:
        raise ValueError(f"Not a cluster node ID: {node_id}")

    # Remove the signal bit (bit 16)
    base_id = node_id - CLUSTER_NODE_MIN_ID

    return {
        "node_index": base_id & 0xF,  # Bits 0-3
        "size_index": (base_id >> 4) & 0x3,  # Bits 4-5
        "large_socket_index": (base_id >> 6) & 0x7,  # Bits 6-8
        "medium_socket_index": (base_id >> 9) & 0x3,  # Bits 9-10
    }


def get_cluster_nodes_from_tree(allocated_nodes: Set[int]) -> Set[int]:
    """
    Extract cluster jewel node IDs from a set of allocated nodes.

    Args:
        allocated_nodes: Set of all allocated node IDs

    Returns:
        Set of cluster jewel node IDs (>= 65536)
    """
    return {node_id for node_id in allocated_nodes if is_cluster_node_id(node_id)}


# For testing
if __name__ == "__main__":
    # Test cluster node ID decoding
    test_id = 65536 + (2 << 4) + (1 << 6) + 5  # Size 2, large index 1, node 5
    decoded = decode_cluster_node_id(test_id)
    print(f"Decoded {test_id}: {decoded}")

    # Would test with a build that has cluster jewels
    print("\nCluster jewel module loaded successfully")
